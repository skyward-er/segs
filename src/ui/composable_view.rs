use super::{
    layout_manager::LayoutManager,
    panes::{Pane, PaneBehavior, PaneKind},
    shortcuts,
    utils::maximized_pane_ui,
};
use std::{
    fs,
    path::{Path, PathBuf},
};

use egui::{Key, Modifiers};
use egui_tiles::{Behavior, Container, Linear, LinearDir, Tile, TileId, Tiles, Tree};
use serde::{Deserialize, Serialize};

#[derive(Default)]
pub struct ComposableView {
    /// Persistent state of the app
    pub state: ComposableViewState,

    pub layout_manager: LayoutManager,
    behavior: ComposableBehavior,
    maximized_pane: Option<TileId>,
}

// An app must implement the `App` trait to define how the ui is built
impl eframe::App for ComposableView {
    // The update function is called each time the UI needs repainting!
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        let panes_tree = &mut self.state.panes_tree;

        // Get the id of the hovered pane, in order to apply actions to it
        let hovered_pane = panes_tree
            .tiles
            .iter()
            .find(|(_, tile)| matches!(tile, Tile::Pane(pane) if pane.contains_pointer()))
            .map(|(id, _)| *id);

        // Capture any pane action generated by pane children
        let pane_action = self.behavior.action.take();
        let mut pane_action = pane_action.zip(hovered_pane);

        // Capture any pane action generated by keyboard shortcuts
        if let Some(hovered_pane) = hovered_pane {
            let key_action_pairs = [
                ((Modifiers::NONE, Key::V), PaneAction::SplitV),
                ((Modifiers::NONE, Key::H), PaneAction::SplitH),
                ((Modifiers::NONE, Key::C), PaneAction::Close),
                ((Modifiers::SHIFT, Key::Escape), PaneAction::Maximize),
            ];
            pane_action = pane_action.or(shortcuts::map_to_action(ctx, &key_action_pairs[..])
                .map(|action| (action, hovered_pane)));
        }

        // If an action was triggered, we consume it
        if let Some((action, hovered_tile)) = pane_action.take() {
            match action {
                PaneAction::SplitH => {
                    let hovered_tile_pane = panes_tree.tiles.remove(hovered_tile).unwrap();
                    let left_pane = panes_tree.tiles.insert_new(hovered_tile_pane);
                    let right_pane = panes_tree.tiles.insert_pane(Pane::default());
                    panes_tree.tiles.insert(
                        hovered_tile,
                        Tile::Container(Container::Linear(Linear::new_binary(
                            LinearDir::Horizontal,
                            [left_pane, right_pane],
                            0.5,
                        ))),
                    );
                }
                PaneAction::SplitV => {
                    let hovered_tile_pane = panes_tree.tiles.remove(hovered_tile).unwrap();
                    let replaced = panes_tree.tiles.insert_new(hovered_tile_pane);
                    let lower_pane = panes_tree.tiles.insert_pane(Pane::default());
                    panes_tree.tiles.insert(
                        hovered_tile,
                        Tile::Container(Container::Linear(Linear::new_binary(
                            LinearDir::Vertical,
                            [replaced, lower_pane],
                            0.5,
                        ))),
                    );
                }
                PaneAction::Close => {
                    // Ignore if the root pane is the only one
                    if panes_tree.tiles.len() != 1 {
                        panes_tree.remove_recursively(hovered_tile);
                    }
                }
                PaneAction::Replace(new_pane) => {
                    panes_tree.tiles.insert(hovered_tile, Tile::Pane(*new_pane));
                }
                PaneAction::Maximize => {
                    // This is a toggle: if there is not currently a maximized pane,
                    // maximize the hovered pane, otherwize remove the maximized pane.
                    if self.maximized_pane.is_some() {
                        self.maximized_pane = None;
                    } else {
                        let hovered_pane_is_default = panes_tree
                            .tiles
                            .get(hovered_tile)
                            .map(|hovered_pane| match hovered_pane {
                                Tile::Pane(Pane {
                                    pane: PaneKind::Default(_),
                                }) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        if !hovered_pane_is_default {
                            self.maximized_pane = Some(hovered_tile);
                        }
                    }
                }
            }
        }

        // Show a panel at the bottom of the screen with few global controls
        egui::TopBottomPanel::bottom("bottom_control").show(ctx, |ui| {
            ui.horizontal(|ui| {
                egui::global_theme_preference_switch(ui);

                if ui.button("Layout Manager").clicked() {
                    self.layout_manager.toggle_open_state();
                }
            })
        });

        // A central panel covers the remainder of the screen, i.e. whatever area is left after adding other panels.
        egui::CentralPanel::default().show(ctx, |ui| {
            if let Some(maximized_pane) = self.maximized_pane {
                if let Some(Tile::Pane(pane)) = panes_tree.tiles.get_mut(maximized_pane) {
                    maximized_pane_ui(ui, pane);
                } else {
                    panic!("Maximized pane not found in tree!");
                }
            } else {
                panes_tree.ui(&mut self.behavior, ui);
            }
        });

        LayoutManager::show(self, ctx);
    }

    fn save(&mut self, storage: &mut dyn eframe::Storage) {
        self.layout_manager.save_displayed(storage);
    }
}

impl ComposableView {
    pub fn new(app_name: &str, storage: &dyn eframe::Storage) -> Self {
        let layout_manager = LayoutManager::new(app_name, storage);
        let mut composable_view = Self {
            layout_manager,
            ..Self::default()
        };
        LayoutManager::try_display_selected_layout(&mut composable_view);
        composable_view
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct ComposableViewState {
    pub panes_tree: Tree<Pane>,
}

impl Default for ComposableViewState {
    fn default() -> Self {
        let mut tiles = Tiles::default();
        let root = tiles.insert_pane(Pane::default());
        let panes_tree = egui_tiles::Tree::new("main_tree", root, tiles);

        Self { panes_tree }
    }
}

impl ComposableViewState {
    pub fn from_file(path: &PathBuf) -> Option<Self> {
        match fs::read_to_string(path) {
            Ok(json) => match serde_json::from_str::<ComposableViewState>(&json) {
                Ok(layout) => Some(layout),
                Err(e) => {
                    eprintln!("Error deserializing layout: {}", e);
                    None
                }
            },
            Err(e) => {
                eprintln!("Error reading file: {}", e);
                None
            }
        }
    }

    pub fn to_file(&self, path: &Path) {
        // Check if the parent path exists, if not create it
        if let Some(parent) = path.parent() {
            if !parent.exists() {
                match fs::create_dir_all(parent) {
                    Ok(_) => {
                        println!("Created directory {:?}", parent);
                    }
                    Err(e) => {
                        eprintln!("Error creating directory: {}", e);
                        return;
                    }
                }
            }
        }

        match serde_json::to_string_pretty(self) {
            Ok(serialized_layout) => {
                println!("Saving layout into {:?}", path);
                fs::write(path, serialized_layout).unwrap();
            }
            Err(e) => {
                eprintln!("Error serializing layout: {}", e);
            }
        }
    }
}

/// Behavior for the tree of panes in the composable view
#[derive(Default)]
pub struct ComposableBehavior {
    pub action: Option<PaneAction>,
}

impl Behavior<Pane> for ComposableBehavior {
    fn pane_ui(
        &mut self,
        ui: &mut egui::Ui,
        _tile_id: TileId,
        pane: &mut Pane,
    ) -> egui_tiles::UiResponse {
        let PaneResponse {
            action_called,
            drag_response,
        } = pane.ui(ui);
        // Capture the action and store it to be consumed in the update function
        if let Some(action_called) = action_called {
            self.action = Some(action_called);
        }
        drag_response
    }

    fn tab_title_for_pane(&mut self, _pane: &Pane) -> egui::WidgetText {
        "Tab".into()
    }
}

#[derive(Clone, Debug)]
pub struct PaneResponse {
    pub action_called: Option<PaneAction>,
    pub drag_response: egui_tiles::UiResponse,
}

impl PaneResponse {
    pub fn set_action(&mut self, action: PaneAction) {
        self.action_called = Some(action);
    }

    pub fn set_drag_started(&mut self) {
        self.drag_response = egui_tiles::UiResponse::DragStarted;
    }
}

impl Default for PaneResponse {
    fn default() -> Self {
        Self {
            action_called: None,
            drag_response: egui_tiles::UiResponse::None,
        }
    }
}

#[derive(Clone, Debug)]
pub enum PaneAction {
    SplitH,
    SplitV,
    Close,
    Replace(Box<Pane>),
    Maximize,
}
